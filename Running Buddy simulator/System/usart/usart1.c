#include <stm32f10x.h>
#include <stdio.h>
#include "usart1.h"
#include "usart3.h"
#include <string.h>
#include <stdbool.h>

char Usart1RecBuf[USART1_RXBUFF_SIZE];//串口1接收数据缓存
unsigned int RxCounter = 0;   //串口1收到数据标志位

//////////////////////////////////////////////////////////////////
//加入以下代码,支持printf函数,而不需要选择use MicroLIB	  
#if 1
#pragma import(__use_no_semihosting)             
//标准库需要的支持函数                 
struct __FILE 
{ 
	int handle; 

}; 

FILE __stdout;       
//定义_sys_exit()以避免使用半主机模式    
_sys_exit(int x) 
{ 
	x = x; 
} 

//重定义fputc函数 
int fputc(int ch, FILE *f)
{      
	while((USART1->SR&0X40)==0);//循环发送,直到发送完毕   
    USART1->DR = (u8) ch;      
	return ch;
}

#endif



/****************************************************************************

描述：Usart1 初始化 
   PA9： USART1_TX
   PA10: USART1_RX

参数：none

返回: none

****************************************************************************/

void uart1_Init(u32 bound)
{
    //GPIO端口设置
  GPIO_InitTypeDef GPIO_InitStructure;
  USART_InitTypeDef USART_InitStructure;
  NVIC_InitTypeDef NVIC_InitStructure;	 
  RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1|RCC_APB2Periph_GPIOA|RCC_APB2Periph_AFIO, ENABLE);
	
	USART_DeInit(USART1);  
 
     //USART1_TX   PA.9
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
  GPIO_Init(GPIOA, &GPIO_InitStructure);
   
    //USART1_RX	  PA.10
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
  GPIO_Init(GPIOA, &GPIO_InitStructure);  

   //Usart1 NVIC 配置

  NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=0 ;
  NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;		

  NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;	//IRQ通道使能
  NVIC_Init(&NVIC_InitStructure);	//根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器USART1
  
   //USART 初始化设置
  USART_InitStructure.USART_BaudRate = bound;//一般设置为9600;
  USART_InitStructure.USART_WordLength = USART_WordLength_8b;
  USART_InitStructure.USART_StopBits = USART_StopBits_1;
  USART_InitStructure.USART_Parity = USART_Parity_No;
  USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
  USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;

  USART_Init(USART1, &USART_InitStructure);
   

  USART_Init(USART1, &USART_InitStructure);     //初始化串口1
  USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);//开启串口1接受中断
  USART_ITConfig(USART1, USART_IT_IDLE, DISABLE);//使能串口1总线空闲中断/
  USART_Cmd(USART1, ENABLE);                    //使能串口1 
}

u8 buf[7]={0};
u8 nums=0;
u8 uart_rev_start = 0;     //接收开始标志
extern bool AppConnectState;
bool usart_rx_start=0;
bool usart_rx_stop=0;
void USART1_IRQHandler(void)                	//串口1中断服务程序
{
	  char ch;
	
		if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)  //接收中断，可以扩展来控制
		{
        ch = USART_ReceiveData(USART1);//接收模块的数据
			  if ((ch == '&') && (usart_rx_start == 0))  //如果收到字符'&'，便开始接收
				{
						usart_rx_start = 1;
					  /* 为了不影响串口中断接收，暂时先把定时器中断关闭 */
					  TIM_Cmd(TIM3,DISABLE);
						TIM_ITConfig(TIM3,TIM_IT_Update,DISABLE );
						TIM_ClearITPendingBit(TIM3, TIM_IT_Update); // 清除中断标志位  
						RxCounter = 0;
				}
			
			  if(usart_rx_start == 1)
			  {
						Usart1RecBuf[RxCounter++] = ch;
						if (ch == '\n') 	//如果接收到换行
						{
								Usart1RecBuf[RxCounter] = '\n';
								usart_rx_stop  = 1;
							  usart_rx_start = 0;
							  RxCounter = 0;
						}
				}

			  if ((ch == 'C') && (uart_rev_start == 0))  //如果收到字符'C'，便开始接收
				{
					uart_rev_start = 1;
					nums = 0;
				}
				if(uart_rev_start == 1)
				{
					  buf[nums++] = ch;  //字符存到数组中
					  if(nums >= 7)
						{
								nums = 0;
							  uart_rev_start = 0;
							  /* 校验是否连接成功 */
							  if((buf[0]=='C')&&(buf[1]=='O')&&(buf[2]=='N')&&(buf[3]=='N')&&(buf[4]=='E')&&(buf[5]=='C')&&(buf[6]=='T'))
								{
										AppConnectState = 1; //连接成功标志置1
								}
						}
			  }
    } 
		USART_ClearITPendingBit(USART1, USART_IT_RXNE);
} 

void uart1_SendStr(char*SendBuf)//串口1打印数据
{
	while(*SendBuf)
	{
	  while((USART1->SR&0X40)==0);//等待发送完成 
    USART1->DR = (u8) *SendBuf; 
		SendBuf++;
	}
}

void UsartSendBufClear(u16 len,char *buf,char *temp)//清除发送缓存
{
	  u8 i,k=0;
	  unsigned char dat = 0,dat1 = 0;
	
	  for(i = 0 ; i < len ;i++)
		{
				buf[i] = 0;
		}
	
		for(i = 0 ; i < strlen(temp) ;i++)
		{
			if(i%2==0)
			{
				if ((temp[i]>='0') && (temp[i]<='9'))
						dat = temp[i]-'0' ;
				 if ((temp[i]>='A') && (temp[i]<='F'))
						dat =  temp[i]+10-'A' ;
				 if ((temp[i]>='a') && (temp[i]<='f'))
						dat =  temp[i]+10-'a' ;
			}
				
			if(i%2==1)
			{
				if ((temp[i]>='0') && (temp[i]<='9'))
						dat1 = temp[i]-'0' ;
				 if ((temp[i]>='A') && (temp[i]<='F'))
						dat1 =  temp[i]+10-'A' ;
				 if ((temp[i]>='a') && (temp[i]<='f'))
						dat1 =  temp[i]+10-'a' ;

					buf[k] = dat*16 + dat1;
					k ++;
			}	
		}
}

void uart1_send(unsigned char *bufs,unsigned char len)
{
	  if(len != 0xFF)
		{
				while (len--)
				{
						while((USART1->SR&0X40)==0);//等待发送完成 
						USART1->DR = (u8) *bufs; 
						bufs ++;
				}
		}
		else//如果字长等于或超过255，不按用户写入字长发送
    {
        for (; *bufs != 0;	bufs++) 	//把字符逐个发送出去
			  {
						while((USART1->SR&0X40)==0);//等待发送完成 
						USART1->DR = (u8) *bufs; 
				}
    }
}


